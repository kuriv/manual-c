# 自引用结构

可以使用结构定义二叉树结构。

```c
#include <stdio.h>

struct node
{
	int data;
	struct node *left;
	struct node *right;
};

int main(int argc, char const *argv[])
{
	struct node rootNode, leftNode, rightNode;
	rootNode.data = 1;
	rootNode.left = &leftNode;
	rootNode.right = &rightNode;
	leftNode.data = 2;
	leftNode.left = NULL;
	leftNode.right = NULL;
	rightNode.data = 3;
	rightNode.left = NULL;
	rightNode.right = NULL;
	printf("root: %d.\n", rootNode.data);
	printf("left: %d.\n", rootNode.left->data);
	printf("right: %d.\n", rootNode.right->data);
	return 0;
}
```

执行下面的代码，动态分配结构的存储空间。

```c
#include <stdio.h>
#include <stdlib.h>

struct node
{
	int data;
	struct node *left;
	struct node *right;
};

int main(int argc, char const *argv[])
{
	struct node *rootNode = (struct node *)malloc(sizeof(struct node));
	struct node *leftNode = (struct node *)malloc(sizeof(struct node));
	struct node *rightNode = (struct node *)malloc(sizeof(struct node));
	rootNode->data = 1;
	rootNode->left = leftNode;
	rootNode->right = rightNode;
	leftNode->data = 2;
	leftNode->left = NULL;
	leftNode->right = NULL;
	rightNode->data = 3;
	rightNode->left = NULL;
	rightNode->right = NULL;
	printf("root: %d.\n", rootNode->data);
	printf("left: %d.\n", rootNode->left->data);
	printf("right: %d.\n", rootNode->right->data);
	free(rootNode);
	free(leftNode);
	free(rightNode);
	return 0;
}
```

